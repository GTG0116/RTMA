<html>
<head>
    <title>RTMA Weather Viewer</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
    <style>
        /* ===== RESET & BASE ===== */
        *, *::before, *::after { box-sizing: border-box; }

Expand 133 hidden lines
        }
 
        /* ===== VALUE POPUP ===== */
        .value-popup .leaflet-popup-content-wrapper {
        .mapboxgl-popup { z-index: 1001; }
        .mapboxgl-popup-content {
            background: rgba(6, 18, 52, 0.88);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(100, 160, 255, 0.25);
            border-radius: 10px;
            box-shadow: 0 6px 24px rgba(0,0,50,0.6);
            color: #e0f0ff;
            padding: 0;
        }
        .value-popup .leaflet-popup-content {
            margin: 10px 14px;
            padding: 10px 14px;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        }
        .value-popup .leaflet-popup-tip-container { display: none; }
        .value-popup .leaflet-popup-close-button {
            color: #60a5fa !important; font-size: 16px;
            top: 4px; right: 6px;
        }
        .mapboxgl-popup-close-button { color: #60a5fa !important; font-size: 16px; }
        .popup-layer-name {
            font-size: 9px; font-weight: 700; letter-spacing: 0.12em;
            text-transform: uppercase; color: #60a5fa; margin-bottom: 3px;

Expand 4 hidden lines
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .popup-coords {
            font-size: 10px; color: #475569; margin-top: 3px;
        }
        .popup-unavailable {
            font-size: 13px; color: #64748b; font-style: italic;
        }
        .popup-coords { font-size: 10px; color: #475569; margin-top: 3px; }
        .popup-unavailable { font-size: 13px; color: #64748b; font-style: italic; }
 
        /* ===== LEAFLET OVERRIDES ===== */
        .leaflet-control-zoom { display: none; }
        .leaflet-control-attribution {
            background: rgba(3, 12, 26, 0.65) !important;
            color: rgba(100, 116, 139, 0.75) !important;
            font-size: 9px !important;
            backdrop-filter: blur(6px);
            border-radius: 6px 0 0 0;
        }
        .leaflet-control-attribution a { color: rgba(96, 165, 250, 0.65) !important; }
        /* ===== MAPBOX GL OVERRIDES ===== */
        .mapboxgl-ctrl-logo { display: none; }
        .mapboxgl-ctrl-bottom-right { display: none; }
    </style>
</head>
<body>

Expand 71 hidden lines
    </div>
</div>
 
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
<script>
    var currentOpacity = 0.65;
 
    var map = L.map('map', {
        center: [39.8283, -98.5795],
        zoom: 4,
 
        zoomControl: false,
        wheelDebounceTime: 40
    });
 
    map.createPane('rtmaPane');
    map.getPane('rtmaPane').style.zIndex = 300;
    // Opt the custom pane into Leaflet's CSS zoom animation so the overlay
    // smoothly scales with the tiles instead of snapping after each step.
    map.getPane('rtmaPane').classList.add('leaflet-zoom-animated');
=======
        zoomControl: false
    });
 
    // Layer z-index stack:
    //   basemapPane  (z=200) — dark base tiles WITHOUT labels/borders
    //   rtmaPane     (z=300) — RTMA weather image overlays
    //   labelsPane   (z=400) — label/border tiles ON TOP of weather data
    mapboxgl.accessToken = 'pk.eyJ1IjoiZ3RnMDExNiIsImEiOiJjbWxsODV6NXAwNThmM2ZwdWlkYm0xNjFlIn0.vI186twXYzY45nnuV5FucQ';
 
    // basemapPane: below the default tilePane (200) so we use 150
    map.createPane('basemapPane');
    map.getPane('basemapPane').style.zIndex = 150;
    // Prevent basemap pane from capturing pointer events (let clicks pass through)
    map.getPane('basemapPane').style.pointerEvents = 'none';
 
    // rtmaPane: above basemap, below labels
    map.createPane('rtmaPane');
    map.getPane('rtmaPane').style.zIndex = 300;
    map.getPane('rtmaPane').style.pointerEvents = 'none';
    var currentOpacity = 0.65;
 
    // labelsPane: above everything so town names / borders are always visible
    map.createPane('labelsPane');
    map.getPane('labelsPane').style.zIndex = 400;
    map.getPane('labelsPane').style.pointerEvents = 'none';
    // Bounds stored as [minLat, minLon, maxLat, maxLon] internally.
    // Mapbox GL image sources require 4-corner coords: [NW, NE, SE, SW] as [lng, lat].
    var boundsArr = [24.0, -126.0, 50.0, -66.0]; // [minLat, minLon, maxLat, maxLon]
 
    // Convert boundsArr → Mapbox GL 4-corner format [NW, NE, SE, SW]
    function toMapboxCoords(b) {
        var minLat = b[0], minLon = b[1], maxLat = b[2], maxLon = b[3];
        return [
            [minLon, maxLat], // NW  top-left
            [maxLon, maxLat], // NE  top-right
            [maxLon, minLat], // SE  bottom-right
            [minLon, minLat]  // SW  bottom-left
        ];
    }
 
    var statusDiv  = document.getElementById('status');
    var statusText = document.getElementById('status-text');
    var legendDiv  = document.getElementById('legend');
 
    // CartoDB dark basemap WITHOUT labels (z=150, beneath RTMA data)
    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 19,
        pane: 'basemapPane'
    }).addTo(map);
 
    // CartoDB dark labels ONLY (z=400, on top of RTMA data so town names/borders show)
    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_only_labels/{z}/{x}/{y}.png', {
        attribution: '',
        subdomains: 'abcd',
        maxZoom: 19,
        pane: 'labelsPane'
    }).addTo(map);
 
    // BUG FIX: use approximate CONUS bounds as defaults instead of [[0,0],[0,0]].
    // [[0,0],[0,0]] creates a zero-area bounding box; the image is invisible
    // until metadata loads. Defaulting to CONUS bounds means images render
    // immediately (slightly approximate) while metadata fetch is in-flight.
    var defaultBounds = [[24.0, -126.0], [50.0, -66.0]];
    var imageBounds = defaultBounds;  // will be updated after metadata loads
 
    var layers = {
        temp:     L.imageOverlay('./data/temp.png',     defaultBounds, { opacity: currentOpacity, pane: 'rtmaPane', interactive: false }),
        wind:     L.imageOverlay('./data/wind.png',     defaultBounds, { opacity: currentOpacity, pane: 'rtmaPane', interactive: false }),
        apparent: L.imageOverlay('./data/apparent.png', defaultBounds, { opacity: currentOpacity, pane: 'rtmaPane', interactive: false }),
        vis:      L.imageOverlay('./data/vis.png',      defaultBounds, { opacity: currentOpacity, pane: 'rtmaPane', interactive: false }),
        cloud:    L.imageOverlay('./data/cloud.png',    defaultBounds, { opacity: currentOpacity, pane: 'rtmaPane', interactive: false }),
        rh:       L.imageOverlay('./data/rh.png',       defaultBounds, { opacity: currentOpacity, pane: 'rtmaPane', interactive: false })
    };
 
    var legendConfigs = {
        temp:     { title: 'Temperature (°F)',          min: -20, max: 110,  gradient: 'linear-gradient(to right,#30123b,#3c59ff,#00ffff,#7cff00,#ffff00,#ff7f00,#ff0000)', unit: '°F' },
        wind:     { title: 'Wind Speed (mph)',           min: 0,   max: 60,   gradient: 'linear-gradient(to right,#440154,#3b528b,#21908c,#5dc863,#fde725)',                  unit: ' mph' },

Expand 3 hidden lines
        rh:       { title: 'Relative Humidity (%)',     min: 0,   max: 100,  gradient: 'linear-gradient(to right,#ffffd9,#c7e9b4,#41b6c4,#225ea8,#081d58)',                  unit: '%' }
    };
 
    function updateLegend(layerName) {
        if (layerName === 'none') { legendDiv.style.display = 'none'; return; }
        var cfg = legendConfigs[layerName];
        if (!cfg) { legendDiv.style.display = 'none'; return; }
        document.getElementById('legend-title').textContent    = cfg.title;
        document.getElementById('min-label').textContent       = cfg.min;
        document.getElementById('max-label').textContent       = cfg.max;
    var ALL_LAYERS = ['temp', 'wind', 'apparent', 'vis', 'cloud', 'rh'];
 
    // ── Map init ──────────────────────────────────────────────────────────────
    var map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/dark-v11',
        center: [-98.5795, 39.8283],
        zoom: 4
    });
 
    // Once the Mapbox style is fully loaded, add RTMA image sources + layers.
    // Each layer is inserted BEFORE 'settlement-label' so Mapbox renders town
    // names and admin borders on top of the weather data automatically.
    map.on('load', function () {
        var coords = toMapboxCoords(boundsArr);
 
        ALL_LAYERS.forEach(function (name) {
            map.addSource(name + '-src', {
                type: 'image',
                url: './data/' + name + '.png',
                coordinates: coords
            });
 
            map.addLayer({
                id: name + '-layer',
                type: 'raster',
                source: name + '-src',
                paint: { 'raster-opacity': currentOpacity },
                layout: { visibility: name === 'temp' ? 'visible' : 'none' }
            }, 'settlement-label'); // INSERT BEFORE labels → labels render on top
        });
 
        // If metadata already arrived before the style loaded, apply it now
        if (pendingBounds) {
            applyBounds(pendingBounds);
            pendingBounds = null;
        }
        if (pendingLayer) {
            showLayer(pendingLayer);
            pendingLayer = null;
        }
    });
 
    // ── Legend ────────────────────────────────────────────────────────────────
    function updateLegend(name) {
        if (name === 'none' || !legendConfigs[name]) { legendDiv.style.display = 'none'; return; }
        var cfg = legendConfigs[name];
        document.getElementById('legend-title').textContent = cfg.title;
        document.getElementById('min-label').textContent    = cfg.min;
        document.getElementById('max-label').textContent    = cfg.max;
        document.getElementById('legend-gradient').style.background = cfg.gradient;
        legendDiv.style.display = 'block';
    }
 
    function getSelectedLayer() {
        var checked = document.querySelector('input[name="layer"]:checked');
        return checked ? checked.value : 'temp';
        var el = document.querySelector('input[name="layer"]:checked');
        return el ? el.value : 'temp';
    }
 
    // ── Layer switching ───────────────────────────────────────────────────────
    var pendingLayer = null; // set when map style not yet loaded
 
    function showLayer(val) {
        Object.values(layers).forEach(function(l) {
            if (map.hasLayer(l)) map.removeLayer(l);
        if (!map.isStyleLoaded()) { pendingLayer = val; updateLegend(val); loadLayerData(val); return; }
        ALL_LAYERS.forEach(function (name) {
            map.setLayoutProperty(name + '-layer', 'visibility', name === val ? 'visible' : 'none');
        });
        if (val !== 'none' && layers[val]) layers[val].addTo(map);
        updateLegend(val);
        loadLayerData(val);
    }
 
    // Layer radio buttons
    document.querySelectorAll('input[name="layer"]').forEach(function(radio) {
        radio.addEventListener('change', function() { showLayer(radio.value); });
    document.querySelectorAll('input[name="layer"]').forEach(function (radio) {
        radio.addEventListener('change', function () { showLayer(radio.value); });
    });
 
    // Opacity slider
    // ── Opacity slider ────────────────────────────────────────────────────────
    var opacitySlider = document.getElementById('opacity-slider');
    var opacityLabel  = document.getElementById('opacity-value');
    opacitySlider.addEventListener('input', function() {
    opacitySlider.addEventListener('input', function () {
        currentOpacity = opacitySlider.value / 100;
        opacityLabel.textContent = opacitySlider.value + '%';
        Object.values(layers).forEach(function(l) { l.setOpacity(currentOpacity); });
        ALL_LAYERS.forEach(function (name) {
            if (map.getLayer(name + '-layer')) {
                map.setPaintProperty(name + '-layer', 'raster-opacity', currentOpacity);
            }
        });
    });
 
    // ===== INTERACTIVE VALUE LOOKUP =====
    // Binary data files are saved by process_rtma.py as row-major float32 (little-endian).
    // Row 0 = southernmost latitude (matches matplotlib imshow origin='lower').
    var dataCache = {};       // layerName → Float32Array
    var dataMeta = null;      // { rows, cols } of the downsampled grid
    var valuePopup = null;
    // ── Bounds update ─────────────────────────────────────────────────────────
    var pendingBounds = null; // set when map style not yet loaded
 
    function loadLayerData(layerName) {
        if (layerName === 'none' || !dataMeta || !dataMeta.data_rows) return;
        if (dataCache[layerName]) return;  // already loaded
        fetch('./data/' + layerName + '_data.bin')
            .then(function(r) {
                if (!r.ok) throw new Error('No data file for ' + layerName);
                return r.arrayBuffer();
            })
            .then(function(buf) {
                dataCache[layerName] = new Float32Array(buf);
            })
            .catch(function() {
                // Data file not available for this layer (e.g. vis/cloud not in GRIB)
            });
    function applyBounds(b) {
        boundsArr = b;
        var coords = toMapboxCoords(b);
        ALL_LAYERS.forEach(function (name) {
            if (map.getSource(name + '-src')) {
                map.getSource(name + '-src').setCoordinates(coords);
            }
        });
    }
 
    function lookupValue(layerName, latlng) {
        var arr = dataCache[layerName];
        if (!arr || !dataMeta || !dataMeta.data_rows) return null;
 
        var rows = dataMeta.data_rows;
        var cols = dataMeta.data_cols;
        var b = imageBounds;
        var minLat = b[0][0], maxLat = b[1][0];
        var minLon = b[0][1], maxLon = b[1][1];
    // ── Interactive value lookup ───────────────────────────────────────────────
    // process_rtma.py saves downsampled float32 binary files (*_data.bin).
    // Row 0 = southernmost lat (matches imshow origin='lower'), little-endian.
    var dataCache = {};
    var dataMeta  = null;
    var valuePopup = null;
 
        var rowFrac = (latlng.lat - minLat) / (maxLat - minLat);
        var colFrac = (latlng.lng - minLon) / (maxLon - minLon);
    function loadLayerData(name) {
        if (name === 'none' || !dataMeta) return;
        if (dataCache[name]) return;
        fetch('./data/' + name + '_data.bin')
            .then(function (r) { if (!r.ok) throw new Error('missing'); return r.arrayBuffer(); })
            .then(function (buf) { dataCache[name] = new Float32Array(buf); })
            .catch(function () { /* layer may not exist in this GRIB file */ });
    }
 
        // Clamp to valid range
    function lookupValue(name, lng, lat) {
        var arr = dataCache[name];
        if (!arr || !dataMeta) return null;
        var rows   = dataMeta.rows, cols = dataMeta.cols;
        var minLat = boundsArr[0], minLon = boundsArr[1];
        var maxLat = boundsArr[2], maxLon = boundsArr[3];
        var rowFrac = (lat - minLat) / (maxLat - minLat);
        var colFrac = (lng - minLon) / (maxLon - minLon);
        if (rowFrac < 0 || rowFrac > 1 || colFrac < 0 || colFrac > 1) return null;
 
        var row = Math.min(rows - 1, Math.max(0, Math.round(rowFrac * (rows - 1))));
        var col = Math.min(cols - 1, Math.max(0, Math.round(colFrac * (cols - 1))));
        var val = arr[row * cols + col];
 
        if (!isFinite(val) || isNaN(val)) return null;
        return val;
        return (isFinite(val) && !isNaN(val)) ? val : null;
    }
 
    function formatValue(layerName, val) {
        var cfg = legendConfigs[layerName];
    function formatValue(name, val) {
        var cfg = legendConfigs[name];
        if (!cfg) return val.toFixed(1);
        if (layerName === 'temp' || layerName === 'apparent') return val.toFixed(1) + cfg.unit;
        if (layerName === 'wind') return val.toFixed(1) + cfg.unit;
        if (layerName === 'vis')  return val.toFixed(2) + cfg.unit;
        if (layerName === 'cloud' || layerName === 'rh') return Math.round(val) + cfg.unit;
        return val.toFixed(1) + (cfg.unit || '');
        if (name === 'cloud' || name === 'rh') return Math.round(val) + cfg.unit;
        if (name === 'vis') return val.toFixed(2) + cfg.unit;
        return val.toFixed(1) + cfg.unit;
    }
 
    // Double-click / double-tap: show exact value at cursor
    map.on('dblclick', function(e) {
        // Prevent default map zoom on dblclick
        e.originalEvent.preventDefault();
    // Double-click / double-tap → show value popup.
    // Mapbox GL event provides e.lngLat (not Leaflet's e.latlng).
    map.on('dblclick', function (e) {
        var name = getSelectedLayer();
        if (name === 'none') return;
 
        var layerName = getSelectedLayer();
        var cfg = legendConfigs[layerName];
        if (valuePopup) { valuePopup.remove(); valuePopup = null; }
 
        if (valuePopup) {
            map.closePopup(valuePopup);
            valuePopup = null;
        }
        var lng = e.lngLat.lng, lat = e.lngLat.lat;
        var val = lookupValue(name, lng, lat);
        var cfg = legendConfigs[name];
        var html;
 
        var val = lookupValue(layerName, e.latlng);
        var contentHtml;
 
        if (layerName === 'none') {
            return;  // nothing to show
        } else if (val !== null) {
            contentHtml =
                '<div class="popup-layer-name">' + (cfg ? cfg.title : layerName) + '</div>' +
                '<div class="popup-value">' + formatValue(layerName, val) + '</div>' +
                '<div class="popup-coords">' +
                    e.latlng.lat.toFixed(3) + '°, ' + e.latlng.lng.toFixed(3) + '°' +
                '</div>';
        if (val !== null) {
            html = '<div class="popup-layer-name">' + cfg.title + '</div>' +
                   '<div class="popup-value">' + formatValue(name, val) + '</div>' +
                   '<div class="popup-coords">' + lat.toFixed(3) + '°, ' + lng.toFixed(3) + '°</div>';
        } else {
            // Data not loaded yet or out of bounds
            contentHtml =
                '<div class="popup-layer-name">' + (cfg ? cfg.title : layerName) + '</div>' +
                '<div class="popup-unavailable">Data not available</div>' +
                '<div class="popup-coords">' +
                    e.latlng.lat.toFixed(3) + '°, ' + e.latlng.lng.toFixed(3) + '°' +
                '</div>';
            html = '<div class="popup-layer-name">' + cfg.title + '</div>' +
                   '<div class="popup-unavailable">Data not available</div>' +
                   '<div class="popup-coords">' + lat.toFixed(3) + '°, ' + lng.toFixed(3) + '°</div>';
        }
 
        valuePopup = L.popup({ className: 'value-popup', closeButton: true, autoClose: true })
            .setLatLng(e.latlng)
            .setContent(contentHtml)
            .openOn(map);
        valuePopup = new mapboxgl.Popup({ closeButton: true, closeOnClick: true })
            .setLngLat([lng, lat])
            .setHTML(html)
            .addTo(map);
    });
 
    // Disable the default dblclick zoom so our handler works cleanly
    map.doubleClickZoom.disable();
 
    // Show the default layer immediately so images attempt to load right away
    showLayer(getSelectedLayer());
    // Show legend for default layer right away (map layers added on 'load')
    updateLegend(getSelectedLayer());
 
    // Load metadata — update precise bounds and timestamp display
    // ── Metadata fetch ────────────────────────────────────────────────────────
    fetch('./data/metadata.json')
        .then(function(response) {
            if (!response.ok) throw new Error('HTTP ' + response.status);
            return response.json();
        })
        .then(function(meta) {
            var ts = new Date(meta.timestamp).toLocaleString();
        .then(function (r) { if (!r.ok) throw new Error('HTTP ' + r.status); return r.json(); })
        .then(function (meta) {
            statusDiv.classList.remove('loading');
            statusDiv.classList.add('ok');
            statusText.innerHTML =
                '<span style="color:#22c55e;font-weight:600">Live</span> &mdash; ' + ts;
            statusText.innerHTML = '<span style="color:#22c55e;font-weight:600">Live</span> &mdash; ' +
                new Date(meta.timestamp).toLocaleString();
 
            // meta.bounds = [[minLat, minLon], [maxLat, maxLon]]
            var b = meta.bounds;
            imageBounds = [[b[0][0], b[0][1]], [b[1][0], b[1][1]]];
            Object.values(layers).forEach(function(layer) {
                layer.setBounds(imageBounds);
            });
            var newBounds = [b[0][0], b[0][1], b[1][0], b[1][1]];
 
            if (map.isStyleLoaded()) {
                applyBounds(newBounds);
            } else {
                pendingBounds = newBounds;
            }
 
            // Store grid shape for interactive lookup
            if (meta.data_rows && meta.data_cols) {
                dataMeta = { data_rows: meta.data_rows, data_cols: meta.data_cols };
                // Pre-load data for whichever layer is already shown
                dataMeta = { rows: meta.data_rows, cols: meta.data_cols };
                loadLayerData(getSelectedLayer());
            }
 
            // BUG FIX: re-show whichever layer the user currently has selected,
            // rather than unconditionally adding layers.temp regardless of selection.
            showLayer(getSelectedLayer());
            if (map.isStyleLoaded()) {
                showLayer(getSelectedLayer());
            } else {
                pendingLayer = getSelectedLayer();
            }
        })
        .catch(function(err) {
        .catch(function (err) {
            console.error(err);
            statusDiv.classList.remove('loading');
            statusDiv.classList.add('error');
            statusText.innerHTML =
                'No data yet &mdash; pipeline has not run.<br>' +
            statusText.innerHTML = 'No data yet &mdash; pipeline has not run.<br>' +
                '<span style="font-size:11px;color:#64748b">Check GitHub Actions workflow.</span>';
        });
</script>
</body>
</html>
