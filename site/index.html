<!DOCTYPE html>
<html>
<head>
    <title>RTMA Weather Viewer</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        /* ===== RESET & BASE ===== */
        *, *::before, *::after { box-sizing: border-box; }
        body {
            margin: 0; padding: 0;
            background: #030c1a;
            color: #e0f0ff;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        }
        #map { width: 100vw; height: 100vh; }

        /* ===== LIQUID GLASS BASE ===== */
        .glass {
            background: rgba(6, 18, 52, 0.52);
            backdrop-filter: blur(22px) saturate(180%);
            -webkit-backdrop-filter: blur(22px) saturate(180%);
            border: 1px solid rgba(100, 160, 255, 0.18);
            box-shadow:
                0 8px 32px rgba(0, 8, 50, 0.55),
                inset 0 1px 0 rgba(255, 255, 255, 0.07),
                inset 0 -1px 0 rgba(0, 15, 70, 0.4);
            border-radius: 14px;
        }

        /* ===== TITLE BADGE (top-center) ===== */
        #title-badge {
            position: absolute; top: 16px; left: 50%; transform: translateX(-50%);
            z-index: 1000; padding: 9px 22px; pointer-events: none; white-space: nowrap;
        }
        #title-badge .badge-text {
            font-size: 12px; font-weight: 700; letter-spacing: 0.12em;
            text-transform: uppercase;
            background: linear-gradient(135deg, #93c5fd 0%, #60a5fa 50%, #818cf8 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* ===== STATUS PANEL (top-left) ===== */
        #status {
            position: absolute; top: 16px; left: 16px; z-index: 1000;
            padding: 12px 16px; pointer-events: none; min-width: 230px;
            transition: border-color 0.4s;
        }
        #status .status-header {
            display: flex; align-items: center; gap: 6px;
            font-size: 10px; font-weight: 700; letter-spacing: 0.1em;
            text-transform: uppercase; color: #60a5fa; margin-bottom: 5px;
        }
        .status-dot {
            width: 7px; height: 7px; border-radius: 50%; flex-shrink: 0;
            background: #f59e0b; box-shadow: 0 0 6px #f59e0b;
        }
        #status.ok    .status-dot { background: #22c55e; box-shadow: 0 0 6px #22c55e; animation: none; }
        #status.error .status-dot { background: #ef4444; box-shadow: 0 0 6px #ef4444; animation: none; }
        #status.loading .status-dot { animation: pulse 1.4s ease-in-out infinite; }
        #status.error { border-color: rgba(239, 68, 68, 0.3); }
        #status.ok    { border-color: rgba(34, 197, 94, 0.22); }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.25; } }
        .status-text { font-size: 12px; color: #94a3b8; line-height: 1.6; }

        /* ===== CONTROLS PANEL (top-right) ===== */
        #controls {
            position: absolute; top: 16px; right: 16px; z-index: 1000;
            padding: 16px 18px; min-width: 186px;
        }
        .panel-title {
            font-size: 10px; font-weight: 700; letter-spacing: 0.12em;
            text-transform: uppercase; color: #60a5fa;
            margin-bottom: 13px; padding-bottom: 9px;
            border-bottom: 1px solid rgba(100, 160, 255, 0.14);
        }

        /* Custom radio buttons */
        .layer-option {
            display: flex; align-items: center; margin: 9px 0;
            cursor: pointer; user-select: none;
        }
        .layer-option input[type="radio"] { display: none; }
        .radio-dot {
            width: 15px; height: 15px; border-radius: 50%;
            border: 2px solid rgba(100, 160, 255, 0.35);
            margin-right: 10px; flex-shrink: 0;
            transition: border-color 0.2s, background 0.2s, box-shadow 0.2s;
            background: transparent; position: relative;
        }
        .layer-option input[type="radio"]:checked ~ .radio-dot {
            border-color: #3b82f6; background: #3b82f6;
            box-shadow: 0 0 9px rgba(59, 130, 246, 0.65);
        }
        .layer-option input[type="radio"]:checked ~ .radio-dot::after {
            content: ''; position: absolute;
            width: 5px; height: 5px; border-radius: 50%; background: #fff;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
        }
        .layer-label { font-size: 13px; color: #94a3b8; transition: color 0.2s; }
        .layer-option:has(input:checked) .layer-label { color: #e0f2fe; font-weight: 500; }

        /* Opacity Slider */
        .slider-section {
            margin-top: 14px; padding-top: 12px;
            border-top: 1px solid rgba(100, 160, 255, 0.10);
        }
        .slider-header {
            display: flex; justify-content: space-between; align-items: center;
            font-size: 10px; font-weight: 700; letter-spacing: 0.08em;
            text-transform: uppercase; color: #60a5fa; margin-bottom: 8px;
        }
        #opacity-value { color: #93c5fd; }
        #opacity-slider {
            -webkit-appearance: none; width: 100%; height: 3px;
            border-radius: 2px; background: rgba(59, 130, 246, 0.22); outline: none;
            cursor: pointer;
        }
        #opacity-slider::-webkit-slider-thumb {
            -webkit-appearance: none; width: 13px; height: 13px;
            border-radius: 50%; background: #3b82f6; cursor: pointer;
            box-shadow: 0 0 7px rgba(59, 130, 246, 0.7);
        }
        #opacity-slider::-moz-range-thumb {
            width: 13px; height: 13px; border-radius: 50%; background: #3b82f6;
            border: none; box-shadow: 0 0 7px rgba(59, 130, 246, 0.7);
        }

        /* ===== LEGEND (bottom-left) ===== */
        .legend {
            position: absolute; bottom: 24px; left: 16px; z-index: 1000;
            padding: 13px 16px; min-width: 220px; display: none;
        }
        .legend-title {
            font-size: 10px; font-weight: 700; letter-spacing: 0.1em;
            text-transform: uppercase; color: #60a5fa; margin-bottom: 9px;
        }
        .legend-gradient { height: 7px; border-radius: 4px; margin-bottom: 5px; }
        .legend-labels {
            display: flex; justify-content: space-between;
            font-size: 11px; color: #64748b;
        }

        /* ===== VALUE POPUP ===== */
        .value-popup .leaflet-popup-content-wrapper {
            background: rgba(6, 18, 52, 0.88);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(100, 160, 255, 0.25);
            border-radius: 10px;
            box-shadow: 0 6px 24px rgba(0,0,50,0.6);
            color: #e0f0ff;
            padding: 0;
        }
        .value-popup .leaflet-popup-content {
            margin: 10px 14px;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        }
        .value-popup .leaflet-popup-tip-container { display: none; }
        .value-popup .leaflet-popup-close-button {
            color: #60a5fa !important; font-size: 16px;
            top: 4px; right: 6px;
        }
        .popup-layer-name {
            font-size: 9px; font-weight: 700; letter-spacing: 0.12em;
            text-transform: uppercase; color: #60a5fa; margin-bottom: 3px;
        }
        .popup-value {
            font-size: 20px; font-weight: 700;
            background: linear-gradient(135deg, #93c5fd, #818cf8);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .popup-coords {
            font-size: 10px; color: #475569; margin-top: 3px;
        }
        .popup-unavailable {
            font-size: 13px; color: #64748b; font-style: italic;
        }

        /* ===== LEAFLET OVERRIDES ===== */
        .leaflet-control-zoom { display: none; }
        .leaflet-control-attribution {
            background: rgba(3, 12, 26, 0.65) !important;
            color: rgba(100, 116, 139, 0.75) !important;
            font-size: 9px !important;
            backdrop-filter: blur(6px);
            border-radius: 6px 0 0 0;
        }
        .leaflet-control-attribution a { color: rgba(96, 165, 250, 0.65) !important; }
    </style>
</head>
<body>
<div id="map"></div>

<!-- Title badge -->
<div id="title-badge" class="glass">
    <span class="badge-text">RTMA Live Weather</span>
</div>

<!-- Status panel -->
<div id="status" class="glass loading">
    <div class="status-header">
        <span class="status-dot"></span>
        Data Status
    </div>
    <div class="status-text" id="status-text">Fetching latest data...</div>
</div>

<!-- Controls panel -->
<div id="controls" class="glass">
    <div class="panel-title">Weather Layer</div>
    <label class="layer-option">
        <input type="radio" name="layer" value="temp" checked>
        <span class="radio-dot"></span>
        <span class="layer-label">Temperature</span>
    </label>
    <label class="layer-option">
        <input type="radio" name="layer" value="wind">
        <span class="radio-dot"></span>
        <span class="layer-label">Wind Speed</span>
    </label>
    <label class="layer-option">
        <input type="radio" name="layer" value="apparent">
        <span class="radio-dot"></span>
        <span class="layer-label">Apparent Temp</span>
    </label>
    <label class="layer-option">
        <input type="radio" name="layer" value="vis">
        <span class="radio-dot"></span>
        <span class="layer-label">Visibility</span>
    </label>
    <label class="layer-option">
        <input type="radio" name="layer" value="cloud">
        <span class="radio-dot"></span>
        <span class="layer-label">Cloud Cover</span>
    </label>
    <label class="layer-option">
        <input type="radio" name="layer" value="rh">
        <span class="radio-dot"></span>
        <span class="layer-label">Rel. Humidity</span>
    </label>
    <label class="layer-option">
        <input type="radio" name="layer" value="none">
        <span class="radio-dot"></span>
        <span class="layer-label">None</span>
    </label>

    <div class="slider-section">
        <div class="slider-header">
            <span>Opacity</span>
            <span id="opacity-value">65%</span>
        </div>
        <input type="range" id="opacity-slider" min="10" max="100" value="65" step="5">
    </div>
</div>

<!-- Legend -->
<div class="legend glass" id="legend">
    <div class="legend-title" id="legend-title">Temperature (°F)</div>
    <div class="legend-gradient" id="legend-gradient"></div>
    <div class="legend-labels">
        <span id="min-label">-20</span>
        <span id="max-label">110</span>
    </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
    var currentOpacity = 0.65;

    var map = L.map('map', {
        center: [39.8283, -98.5795],
        zoom: 4,

        zoomControl: false,
        wheelDebounceTime: 40
    });

    map.createPane('rtmaPane');
    map.getPane('rtmaPane').style.zIndex = 300;
    // Opt the custom pane into Leaflet's CSS zoom animation so the overlay
    // smoothly scales with the tiles instead of snapping after each step.
    map.getPane('rtmaPane').classList.add('leaflet-zoom-animated');
=======
        zoomControl: false
    });

    // Layer z-index stack:
    //   basemapPane  (z=200) — dark base tiles WITHOUT labels/borders
    //   rtmaPane     (z=300) — RTMA weather image overlays
    //   labelsPane   (z=400) — label/border tiles ON TOP of weather data

    // basemapPane: below the default tilePane (200) so we use 150
    map.createPane('basemapPane');
    map.getPane('basemapPane').style.zIndex = 150;
    // Prevent basemap pane from capturing pointer events (let clicks pass through)
    map.getPane('basemapPane').style.pointerEvents = 'none';

    // rtmaPane: above basemap, below labels
    map.createPane('rtmaPane');
    map.getPane('rtmaPane').style.zIndex = 300;
    map.getPane('rtmaPane').style.pointerEvents = 'none';

    // labelsPane: above everything so town names / borders are always visible
    map.createPane('labelsPane');
    map.getPane('labelsPane').style.zIndex = 400;
    map.getPane('labelsPane').style.pointerEvents = 'none';

    var statusDiv  = document.getElementById('status');
    var statusText = document.getElementById('status-text');
    var legendDiv  = document.getElementById('legend');

    // CartoDB dark basemap WITHOUT labels (z=150, beneath RTMA data)
    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 19,
        pane: 'basemapPane'
    }).addTo(map);

    // CartoDB dark labels ONLY (z=400, on top of RTMA data so town names/borders show)
    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_only_labels/{z}/{x}/{y}.png', {
        attribution: '',
        subdomains: 'abcd',
        maxZoom: 19,
        pane: 'labelsPane'
    }).addTo(map);

    // BUG FIX: use approximate CONUS bounds as defaults instead of [[0,0],[0,0]].
    // [[0,0],[0,0]] creates a zero-area bounding box; the image is invisible
    // until metadata loads. Defaulting to CONUS bounds means images render
    // immediately (slightly approximate) while metadata fetch is in-flight.
    var defaultBounds = [[24.0, -126.0], [50.0, -66.0]];
    var imageBounds = defaultBounds;  // will be updated after metadata loads

    var layers = {
        temp:     L.imageOverlay('./data/temp.png',     defaultBounds, { opacity: currentOpacity, pane: 'rtmaPane', interactive: false }),
        wind:     L.imageOverlay('./data/wind.png',     defaultBounds, { opacity: currentOpacity, pane: 'rtmaPane', interactive: false }),
        apparent: L.imageOverlay('./data/apparent.png', defaultBounds, { opacity: currentOpacity, pane: 'rtmaPane', interactive: false }),
        vis:      L.imageOverlay('./data/vis.png',      defaultBounds, { opacity: currentOpacity, pane: 'rtmaPane', interactive: false }),
        cloud:    L.imageOverlay('./data/cloud.png',    defaultBounds, { opacity: currentOpacity, pane: 'rtmaPane', interactive: false }),
        rh:       L.imageOverlay('./data/rh.png',       defaultBounds, { opacity: currentOpacity, pane: 'rtmaPane', interactive: false })
    };

    var legendConfigs = {
        temp:     { title: 'Temperature (°F)',          min: -20, max: 110,  gradient: 'linear-gradient(to right,#30123b,#3c59ff,#00ffff,#7cff00,#ffff00,#ff7f00,#ff0000)', unit: '°F' },
        wind:     { title: 'Wind Speed (mph)',           min: 0,   max: 60,   gradient: 'linear-gradient(to right,#440154,#3b528b,#21908c,#5dc863,#fde725)',                  unit: ' mph' },
        apparent: { title: 'Apparent Temperature (°F)', min: -40, max: 140,  gradient: 'linear-gradient(to right,#30123b,#3c59ff,#00ffff,#7cff00,#ffff00,#ff7f00,#ff0000)', unit: '°F' },
        vis:      { title: 'Visibility (miles)',         min: 0,   max: 10,   gradient: 'linear-gradient(to right,#0d0221,#3e0072,#9b00c4,#e8007a,#ff6b00,#fffb00)',           unit: ' mi' },
        cloud:    { title: 'Cloud Cover (%)',            min: 0,   max: 100,  gradient: 'linear-gradient(to right,#f7fbff,#c6dbef,#6baed6,#2171b5,#084594)',                  unit: '%' },
        rh:       { title: 'Relative Humidity (%)',     min: 0,   max: 100,  gradient: 'linear-gradient(to right,#ffffd9,#c7e9b4,#41b6c4,#225ea8,#081d58)',                  unit: '%' }
    };

    function updateLegend(layerName) {
        if (layerName === 'none') { legendDiv.style.display = 'none'; return; }
        var cfg = legendConfigs[layerName];
        if (!cfg) { legendDiv.style.display = 'none'; return; }
        document.getElementById('legend-title').textContent    = cfg.title;
        document.getElementById('min-label').textContent       = cfg.min;
        document.getElementById('max-label').textContent       = cfg.max;
        document.getElementById('legend-gradient').style.background = cfg.gradient;
        legendDiv.style.display = 'block';
    }

    function getSelectedLayer() {
        var checked = document.querySelector('input[name="layer"]:checked');
        return checked ? checked.value : 'temp';
    }

    function showLayer(val) {
        Object.values(layers).forEach(function(l) {
            if (map.hasLayer(l)) map.removeLayer(l);
        });
        if (val !== 'none' && layers[val]) layers[val].addTo(map);
        updateLegend(val);
        loadLayerData(val);
    }

    // Layer radio buttons
    document.querySelectorAll('input[name="layer"]').forEach(function(radio) {
        radio.addEventListener('change', function() { showLayer(radio.value); });
    });

    // Opacity slider
    var opacitySlider = document.getElementById('opacity-slider');
    var opacityLabel  = document.getElementById('opacity-value');
    opacitySlider.addEventListener('input', function() {
        currentOpacity = opacitySlider.value / 100;
        opacityLabel.textContent = opacitySlider.value + '%';
        Object.values(layers).forEach(function(l) { l.setOpacity(currentOpacity); });
    });

    // ===== INTERACTIVE VALUE LOOKUP =====
    // Binary data files are saved by process_rtma.py as row-major float32 (little-endian).
    // Row 0 = southernmost latitude (matches matplotlib imshow origin='lower').
    var dataCache = {};       // layerName → Float32Array
    var dataMeta = null;      // { rows, cols } of the downsampled grid
    var valuePopup = null;

    function loadLayerData(layerName) {
        if (layerName === 'none' || !dataMeta || !dataMeta.data_rows) return;
        if (dataCache[layerName]) return;  // already loaded
        fetch('./data/' + layerName + '_data.bin')
            .then(function(r) {
                if (!r.ok) throw new Error('No data file for ' + layerName);
                return r.arrayBuffer();
            })
            .then(function(buf) {
                dataCache[layerName] = new Float32Array(buf);
            })
            .catch(function() {
                // Data file not available for this layer (e.g. vis/cloud not in GRIB)
            });
    }

    function lookupValue(layerName, latlng) {
        var arr = dataCache[layerName];
        if (!arr || !dataMeta || !dataMeta.data_rows) return null;

        var rows = dataMeta.data_rows;
        var cols = dataMeta.data_cols;
        var b = imageBounds;
        var minLat = b[0][0], maxLat = b[1][0];
        var minLon = b[0][1], maxLon = b[1][1];

        var rowFrac = (latlng.lat - minLat) / (maxLat - minLat);
        var colFrac = (latlng.lng - minLon) / (maxLon - minLon);

        // Clamp to valid range
        if (rowFrac < 0 || rowFrac > 1 || colFrac < 0 || colFrac > 1) return null;

        var row = Math.min(rows - 1, Math.max(0, Math.round(rowFrac * (rows - 1))));
        var col = Math.min(cols - 1, Math.max(0, Math.round(colFrac * (cols - 1))));
        var val = arr[row * cols + col];

        if (!isFinite(val) || isNaN(val)) return null;
        return val;
    }

    function formatValue(layerName, val) {
        var cfg = legendConfigs[layerName];
        if (!cfg) return val.toFixed(1);
        if (layerName === 'temp' || layerName === 'apparent') return val.toFixed(1) + cfg.unit;
        if (layerName === 'wind') return val.toFixed(1) + cfg.unit;
        if (layerName === 'vis')  return val.toFixed(2) + cfg.unit;
        if (layerName === 'cloud' || layerName === 'rh') return Math.round(val) + cfg.unit;
        return val.toFixed(1) + (cfg.unit || '');
    }

    // Double-click / double-tap: show exact value at cursor
    map.on('dblclick', function(e) {
        // Prevent default map zoom on dblclick
        e.originalEvent.preventDefault();

        var layerName = getSelectedLayer();
        var cfg = legendConfigs[layerName];

        if (valuePopup) {
            map.closePopup(valuePopup);
            valuePopup = null;
        }

        var val = lookupValue(layerName, e.latlng);
        var contentHtml;

        if (layerName === 'none') {
            return;  // nothing to show
        } else if (val !== null) {
            contentHtml =
                '<div class="popup-layer-name">' + (cfg ? cfg.title : layerName) + '</div>' +
                '<div class="popup-value">' + formatValue(layerName, val) + '</div>' +
                '<div class="popup-coords">' +
                    e.latlng.lat.toFixed(3) + '°, ' + e.latlng.lng.toFixed(3) + '°' +
                '</div>';
        } else {
            // Data not loaded yet or out of bounds
            contentHtml =
                '<div class="popup-layer-name">' + (cfg ? cfg.title : layerName) + '</div>' +
                '<div class="popup-unavailable">Data not available</div>' +
                '<div class="popup-coords">' +
                    e.latlng.lat.toFixed(3) + '°, ' + e.latlng.lng.toFixed(3) + '°' +
                '</div>';
        }

        valuePopup = L.popup({ className: 'value-popup', closeButton: true, autoClose: true })
            .setLatLng(e.latlng)
            .setContent(contentHtml)
            .openOn(map);
    });

    // Disable the default dblclick zoom so our handler works cleanly
    map.doubleClickZoom.disable();

    // Show the default layer immediately so images attempt to load right away
    showLayer(getSelectedLayer());

    // Load metadata — update precise bounds and timestamp display
    fetch('./data/metadata.json')
        .then(function(response) {
            if (!response.ok) throw new Error('HTTP ' + response.status);
            return response.json();
        })
        .then(function(meta) {
            var ts = new Date(meta.timestamp).toLocaleString();
            statusDiv.classList.remove('loading');
            statusDiv.classList.add('ok');
            statusText.innerHTML =
                '<span style="color:#22c55e;font-weight:600">Live</span> &mdash; ' + ts;

            var b = meta.bounds;
            imageBounds = [[b[0][0], b[0][1]], [b[1][0], b[1][1]]];
            Object.values(layers).forEach(function(layer) {
                layer.setBounds(imageBounds);
            });

            // Store grid shape for interactive lookup
            if (meta.data_rows && meta.data_cols) {
                dataMeta = { data_rows: meta.data_rows, data_cols: meta.data_cols };
                // Pre-load data for whichever layer is already shown
                loadLayerData(getSelectedLayer());
            }

            // BUG FIX: re-show whichever layer the user currently has selected,
            // rather than unconditionally adding layers.temp regardless of selection.
            showLayer(getSelectedLayer());
        })
        .catch(function(err) {
            console.error(err);
            statusDiv.classList.remove('loading');
            statusDiv.classList.add('error');
            statusText.innerHTML =
                'No data yet &mdash; pipeline has not run.<br>' +
                '<span style="font-size:11px;color:#64748b">Check GitHub Actions workflow.</span>';
        });
</script>
</body>
</html>
